0x04. Loops, conditions and parsing

ShellCheck - A shell script static analysis tool
ShellCheck is a GPLv3 tool that gives warnings and suggestions for bash/sh shell scripts:

The goals of ShellCheck are

To point out and clarify typical beginner's syntax issues that cause a shell to give cryptic error messages.

To point out and clarify typical intermediate level semantic problems that cause a shell to behave strangely and counter-intuitively.

To point out subtle caveats, corner cases and pitfalls that may cause an advanced user's otherwise working script to fail under future circumstances.

9.1. The for loop
9.1.1. How does it work?
The for loop is the first of the three shell looping constructs. This loop allows for specification of a list of values. A list of commands is executed for each value in the list.

The syntax for this loop is:

for NAME [in LIST ]; do COMMANDS; done

If [in LIST] is not present, it is replaced with in $@ and for executes the COMMANDS once for each positional parameter that is set (see Section 3.2.5 and Section 7.2.1.2).

The return status is the exit status of the last command that executes. If no commands are executed because LIST does not expand to any items, the return status is zero.

NAME can be any variable name, although i is used very often. LIST can be any list of words, strings or numbers, which can be literal or generated by any command. The COMMANDS to execute can also be any operating system commands, script, program or shell statement. The first time through the loop, NAME is set to the first item in LIST. The second time, its value is set to the second item in the list, and so on. The loop terminates when NAME has taken on each of the values from LIST and no items are left in LIST.

assignment

variable assignment
Initializing or changing the value of a variable

=
All-purpose assignment operator, which works for both arithmetic and string assignments.

var=27
category=minerals  # No spaces allowed after the "=".
Caution	
Do not confuse the "=" assignment operator with the = test operator.

#   =  as a test operator

if [ "$string1" = "$string2" ]
then
   command
fi

#  if [ "X$string1" = "X$string2" ] is safer,
#+ to prevent an error message should one of the variables be empty.
#  (The prepended "X" characters cancel out.)
arithmetic operators

+
plus

-
minus

*
multiplication

/
division

**
exponentiation

# Bash, version 2.02, introduced the "**" exponentiation operator.

let "z=5**3"    # 5 * 5 * 5
echo "z = $z"   # z = 125
%
modulo, or mod (returns the remainder of an integer division operation)

bash$ expr 5 % 3
2
	      
5/3 = 1, with remainder 2

This operator finds use in, among other things, generating numbers within a specific range (see Example 9-11 and Example 9-15) and formatting program output (see Example 27-16 and Example A-6). It can even be used to generate prime numbers, (see Example A-15). Modulo turns up surprisingly often in numerical recipes.


A binary comparison operator compares two variables or quantities. Note that integer and string comparison use a different set of operators.

integer comparison

-eq
is equal to

if [ "$a" -eq "$b" ]

-ne
is not equal to

if [ "$a" -ne "$b" ]

-gt
is greater than

if [ "$a" -gt "$b" ]

-ge
is greater than or equal to

if [ "$a" -ge "$b" ]

-lt
is less than

if [ "$a" -lt "$b" ]

-le
is less than or equal to

if [ "$a" -le "$b" ]

<
is less than (within double parentheses)

(("$a" < "$b"))

<=
is less than or equal to (within double parentheses)

(("$a" <= "$b"))

>
is greater than (within double parentheses)

(("$a" > "$b"))

>=
is greater than or equal to (within double parentheses)

(("$a" >= "$b"))

string comparison

=

is equal to

if [ "$a" = "$b" ]

Caution	
Note the whitespace framing the =.

if [ "$a"="$b" ] is not equivalent to the above.

==
is equal to

if [ "$a" == "$b" ]

This is a synonym for =.

Note	
The == comparison operator behaves differently within a double-brackets test than within single brackets.
[[ $a == z* ]]   # True if $a starts with an "z" (pattern matching).
[[ $a == "z*" ]] # True if $a is equal to z* (literal matching).

[ $a == z* ]     # File globbing and word splitting take place.
[ "$a" == "z*" ] # True if $a is equal to z* (literal matching).

# Thanks, Stéphane Chazelas
!=
is not equal to

if [ "$a" != "$b" ]

This operator uses pattern matching within a [[ ... ]] construct.

<
is less than, in ASCII alphabetical order

if [[ "$a" < "$b" ]]

if [ "$a" \< "$b" ]

Note that the "<" needs to be escaped within a [ ] construct.

>
is greater than, in ASCII alphabetical order

if [[ "$a" > "$b" ]]

if [ "$a" \> "$b" ]

Note that the ">" needs to be escaped within a [ ] construct.

See Example 27-11 for an application of this comparison operator.

-z
string is null, that is, has zero length

 String=''   # Zero-length ("null") string variable.

if [ -z "$String" ]
then
  echo "\$String is null."
else
  echo "\$String is NOT null."
fi     # $String is null.

-n
string is not null.

Caution	
The -n test requires that the string be quoted within the test brackets. Using an unquoted string with ! -z, or even just the unquoted string alone within test brackets (see Example 7-6) normally works, however, this is an unsafe practice. Always quote a tested string


File test operators
Returns true if...

-e
file exists

-a
file exists

This is identical in effect to -e. It has been "deprecated," [1] and its use is discouraged.

-f
file is a regular file (not a directory or device file)

-s
file is not zero size

-d
file is a directory

-b
file is a block device


-c
file is a character device

device0="/dev/sda2"    # /   (root directory)
if [ -b "$device0" ]
then
  echo "$device0 is a block device."
fi

# /dev/sda2 is a block device.



device1="/dev/ttyS1"   # PCMCIA modem card.
if [ -c "$device1" ]
then
  echo "$device1 is a character device."
fi

# /dev/ttyS1 is a character device.

-p
file is a pipe

function show_input_type()
{
   [ -p /dev/fd/0 ] && echo PIPE || echo STDIN
}

show_input_type "Input"                           # STDIN
echo "Input" | show_input_type                    # PIPE

# This example courtesy of Carl Anderson.

-h
file is a symbolic link

-L
file is a symbolic link

-S
file is a socket

-t
file (descriptor) is associated with a terminal device

This test option may be used to check whether the stdin [ -t 0 ] or stdout [ -t 1 ] in a given script is a terminal.

-r
file has read permission (for the user running the test)

-w
file has write permission (for the user running the test)

-x
file has execute permission (for the user running the test)

-g
set-group-id (sgid) flag set on file or directory

If a directory has the sgid flag set, then a file created within that directory belongs to the group that owns the directory, not necessarily to the group of the user who created the file. This may be useful for a directory shared by a workgroup.

-u

set-user-id (suid) flag set on file

A binary owned by root with set-user-id flag set runs with root privileges, even when an ordinary user invokes it. [2] This is useful for executables (such as pppd and cdrecord) that need to access system hardware. Lacking the suid flag, these binaries could not be invoked by a non-root user.

	      -rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd
	      
A file with the suid flag set shows an s in its permissions.

-k
sticky bit set

Commonly known as the sticky bit, the save-text-mode flag is a special type of file permission. If a file has this flag set, that file will be kept in cache memory, for quicker access. [3] If set on a directory, it restricts write permission. Setting the sticky bit adds a t to the permissions on the file or directory listing. This restricts altering or deleting specific files in that directory to the owner of those files.

	      drwxrwxrwt    7 root         1024 May 19 21:26 tmp/
	      
If a user does not own a directory that has the sticky bit set, but has write permission in that directory, she can only delete those files that she owns in it. This keeps users from inadvertently overwriting or deleting each other's files in a publicly accessible directory, such as /tmp. (The owner of the directory or root can, of course, delete or rename files there.)

-O
you are owner of file

-G
group-id of file same as yours

-N
file modified since it was last read

f1 -nt f2
file f1 is newer than f2

f1 -ot f2
file f1 is older than f2

f1 -ef f2
files f1 and f2 are hard links to the same file

!
"not" -- reverses the sense of the tests above (returns true if condition absent).



Make Linux/Unix Script Portable With #!/usr/bin/env As a Shebang
Author: Vivek Gite Last updated: September 30, 2023 32 comments
You may notice that most shell and Perl script starts with the following line:
#!/bin/bash
OR
#!/usr/bin/perl
Let us find out why is it a good idea to use #!/usr/bin/env bash instead of #!/bin/bash as shebang?

#!/usr/bin/env As a Shebang
The #! is called a shebang. It consists of a number sign and an exclamation point character (#!), followed by the full path to the interpreter such as /bin/bash. All scripts under Linux, *BSD, macOS, and Unix-like system execute using the interpreter specified on a first line. However, there is a small problem. BASH or Perl is not always in the same location (PATH) such as /bin/bash or /usr/bin/perl. If you want to make sure that script is portable across different UNIX like operating systems you need to use /usr/bin/env command as shebang.


Make Linux/Unix Script Portable With #!/usr/bin/env As a Shebang
The env command allows to run a program in a modified environment. First, find line
#!/bin/bash

Replace with
#!/usr/bin/env bash

For example here is a small bash shell script:

#!/usr/bin/env bash
x=5
y=10
echo "$x and $y"
The advantage of #!/usr/bin/env bash is that it will use whatever bash executable appears first in the running user’s $PATH variable. If you have two version of bash installed as follows and PATH set to /home/vivek/bin:/usr/local/bin:/usr/bin:/bin:/usr/games/bin:/bin:/usr/bin, than bash4 will execute the script:

/bin/bash # <-- bash3
/usr/local/bin/bash # <-- bash4
Using env in the shebang of a script
env is a shell command for Unix-like operating systems. We can use it for various purposes. For example:

Display a list of environment variables
Run another command in a modified environment
Add or remove variables
Change the value of existing variables
To show current environment variables defined by your shell, run env command:
env

We can filter out infromation using the grep command/egrep command as follows:
env | grep HOME
env | grep -E 'HOME|USER|VERSION|SHELL|PWD'

Outputs:

SHELL=/bin/bash
GNOME_SHELL_SESSION_MODE=ubuntu
PWD=/tmp
HOME=/home/vivek
USERNAME=vivek
VTE_VERSION=6003
USER=vivek
OLDPWD=/tmp
Let us see some more examples.

Perl example
#!/usr/bin/env perl
use warnings;
print "Hello " x 5;
print "\\n";
Python2.x example:

#!/usr/bin/env python
x=10
y=20
z=x+y
print z
Another example with python3:
#!/usr/bin/env python3
import boto3
t = boto3.resource('s3')
for b in t.buckets.all():
     print(b.name)
Is env always located at /usr/bin/env
You can use the type command or command command to locate exact path for the env command:
type env
command -V env

Sample outputs:

env is /usr/bin/env
